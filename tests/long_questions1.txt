(1_Introduction.pdf)(Which statement accurately distinguishes the fundamental difference and relationship between Computer Science, Software Engineering, and System Engineering, based on their defined scopes and focus areas?)(A) (Computer Science primarily concentrates on the theoretical underpinnings and foundational principles that govern computing systems, while Software Engineering is a distinct but broader discipline focused on the practical application of these theories to all aspects of hardware, software, and process development.)(B) (System Engineering encompasses the entire development cycle of complex computer-based systems, including hardware, software, and process design, making Software Engineering a specialized subset concerned exclusively with the practical production and delivery of useful software components within that larger framework.)(C) (Software Engineering is defined as the engineering discipline concerned with the cost-effective development of software systems and associated documentation, whereas Computer Science focuses solely on the commercial practicalities of delivering market-ready, dependable, and maintainable software products to a paying customer base.)(D) (The primary distinction is that Computer Science handles the initial specification phase, defining system requirements and constraints, whereas Software Engineering is concerned with system validation and evolution, modifying systems after initial delivery to reflect long-term market requirements and changing organizational policies.)(B)

--------------------------------------------------------------------------------
(1_Introduction.pdf)(The inherent attributes of good software are listed as maintainability, dependability and security, efficiency, and acceptability. Which combination of characteristics best illustrates how Maintainability and Dependability and security influence the system's long-term utility and integrity?)(A) (Maintainability is crucial because it ensures the software can always be evolved to meet rapidly changing business requirements, while Dependability primarily relates to the cost-effectiveness and speed with which new versions of software are able to be released to the general market.)(B) (Dependability and security dictate that the software should minimize wasteful usage of system resources like memory and processing time, whereas Maintainability ensures that the system is compatible with other legacy systems used by the target group of end-users.)(C) (Maintainability requires the system to be developed so it can accommodate inevitable changes due to business evolution, and Dependability requires the system to be reliable, safe, and secure, ensuring it causes no physical or economic harm and resists malicious access attempts.)(D) (Maintainability focuses on the software delivering the required functionality and performance to the user in a timely manner, while Dependability and security are primarily concerned with ensuring the software's structure is optimized to support incremental, component-based integration with external web services.)(C)

--------------------------------------------------------------------------------
(1_Introduction.pdf)(Consider the implications of software costs in developed nations and throughout the lifecycle of long-term systems. Which conclusion regarding software economics is consistently supported by the data on expenditure and maintenance?)(A) (While software expenditure constitutes a significant portion of GNP in all developed countries, the overwhelming majority of project costs, typically around 60%, are dedicated to testing and quality assurance, leaving a small fraction for initial development activities.)(B) (The most critical factor influencing software project budgets is the initial development cost, which typically includes roughly 60% for coding and 40% for testing, and these costs are almost always several times greater than the subsequent long-term maintenance required.)(C) (The economies of developed nations are fundamentally reliant on software systems, and for systems designed to operate over many years, the continuous process of software maintenance frequently accrues costs that exceed the original development costs several times over.)(D) (Although systems are becoming increasingly software-controlled, current software engineering techniques have already eliminated most project failures, meaning the expenditure on software development and maintenance is consistently decreasing relative to the Gross National Product (GNP).)(C)

--------------------------------------------------------------------------------
(1_Introduction.pdf)(When distinguishing between Generic products and Customized products, what fundamental difference governs the ownership and process of specifying required software changes?)(A) (Generic products, like embedded control systems or air traffic control software, have specifications owned by the commissioning customer, whereas Customized products, like graphics programs or project management tools, have specifications owned by the software developer who mandates changes.)(B) (Customized products are stand-alone systems marketed to any customer wishing to purchase them, meaning the developer retains ownership of the specification, contrasting with Generic products, which are specifically commissioned by a customer whose needs dictate the change process and final specification.)(C) (For Generic products, the software developer retains ownership of the specification and is responsible for making decisions regarding software changes, while for Customized products, the specific customer who commissioned the software holds the ownership and decides on the necessary modifications.)(D) (Generic products are characterized by their integration into larger systems of systems and their primary reliance on web-based service infrastructure, while Customized products are usually stand-alone applications that rely solely on local computer resources without any required network connectivity.)(C)

--------------------------------------------------------------------------------
(1_Introduction.pdf)(The ACM/IEEE Code of Ethics outlines eight principles guiding professional software engineers. How do Principles 1 (PUBLIC) and 2 (CLIENT AND EMPLOYER) interact when a software engineer must make a decision involving conflicting interests?)(A) (Principle 2 mandates that engineers must prioritize the financial interests and strategic goals of their Client and Employer above all other considerations, as the commitment to the Public interest is only an abstract ideal reserved for policy makers, not practitioners.)(B) (Principle 1 establishes the fundamental responsibility that software engineers must act consistently with the public interest, and Principle 2 clarifies that actions taken in the best interests of the Client and Employer must always be congruent and consistent with this overriding public interest.)(C) (Principle 1 requires commitment to lifelong learning and the promotion of ethical practice, ensuring continuous professional development, while Principle 2 requires the engineer to be fair to and supportive of their colleagues within the professional community.)(D) (The two principles operate sequentially: Principle 1 applies during the system specification phase to ensure social compatibility, and Principle 2 applies exclusively during the evolution phase, governing contractual negotiations for system maintenance and necessary modifications.)(B)

--------------------------------------------------------------------------------
(1_Introduction.pdf)(A software engineer is facing an ethical dilemma involving a safety-critical system scheduled for release by management despite incomplete testing. Based on the ACM/IEEE Code of Ethics, which principle provides the strongest ethical framework for the engineer's commitment in this situation?)(A) (The principle of PROFESSION requires the engineer to advance the integrity and reputation of the profession, which suggests discreetly documenting the issue internally but avoiding public disclosure to prevent reputational damage that affects the entire software engineering community.)(B) (The principle of CLIENT AND EMPLOYER requires the engineer to act in the best interests of the employer, meaning they should prioritize the scheduled release to meet organizational commitments, even if potential risks exist due to pressure from senior management.)(C) (The principle of PUBLIC, which demands software engineers act consistently with the public interest and adhere to the health, safety, and welfare of the public, necessitates raising concerns and potentially refusing to participate in the release of an inadequately tested safety-critical system.)(D) (The principle of SELF requires continuous lifelong learning, implying the engineer should first acquire more knowledge about the system's remaining defects to determine whether the untested components are strictly safety-critical or merely non-functional aspects of the overall design.)(C)

--------------------------------------------------------------------------------
(1_Introduction.pdf)(Analyze the Mentcare patient information system, designed for mental health care management. What complex, intertwined system concerns must the software engineering team prioritize due to the sensitive nature of the system and its operational context?)(A) (The primary focus must be on Efficiency, ensuring the system uses minimal memory and processing cycles, and Acceptability, guaranteeing the system is fully compatible with every possible hardware configuration used in community centers and hospital clinics.)(B) (The core concerns are Maintainability, ensuring the system can easily be adapted for future integration with commercial e-commerce platforms, and Scale, guaranteeing the database can handle millions of simultaneous transactions from global users.)(C) (Crucial system concerns are Privacy, requiring patient information confidentiality only accessible to authorized medical staff and the patient, and Safety, ensuring system availability for correct medication prescription and providing warnings about potentially suicidal or dangerous patients.)(D) (The system must prioritize Software Reuse, ensuring all components are derived from pre-existing open-source libraries to minimize development costs, and Rich Interfaces, providing advanced AJAX and HTML5 features regardless of the client site's network reliability.)(C)

--------------------------------------------------------------------------------
(1_Introduction.pdf)(How does the architectural context of the iLearn digital learning environment—specifically its reliance on being a service-oriented system—fundamentally impact its flexibility and configuration capabilities?)(A) (As a service-oriented system, iLearn requires all software components to be tightly coupled and monolithic, which minimizes the communication overhead but necessitates deploying the entire system as a single, large update whenever any single component service requires modification or replacement.)(B) (The service-oriented nature means all system components are treated as replaceable services, enabling the system to be rapidly configured and updated incrementally as new services become available, allowing customized versions for different user groups, such as young children or senior students.)(C) (iLearn primarily uses Independent Services, which offers direct service-to-service communication via an Application Programming Interface (API), requiring explicit user actions like copy/paste for information sharing across the environment.)(D) (The service-oriented approach dictates that iLearn must abandon all fundamental software engineering principles in favor of continuous prototyping and testing, as the web platform environment renders traditional specification and validation activities irrelevant for complex distributed systems.)(B)

--------------------------------------------------------------------------------
(2_SW Processes.pdf)(The Waterfall model is characterized by its distinct, separate phases of specification, development, and validation. In which specific project circumstances is the Waterfall model considered an appropriate, rather than detrimental, choice for software development?)(A) (When informal team communication is highly valued and frequent changes to the software requirements are anticipated, necessitating a process where implementation and design are continuously inter-leaved to maximize customer feedback frequency.)(B) (For systems where the requirements are extremely difficult to define clearly upfront and must be discovered through frequent customer demonstrations and experimentation with delivered software increments, such as cutting-edge entertainment systems or mobile applications.)(C) (In projects where system complexity must be managed through incremental delivery and rapid development cycles, prioritizing speed and rapid customer feedback over the creation of comprehensive and highly detailed documentation for regulatory compliance.)(D) (When the system requirements are clearly understood and changes during the design process are expected to be fairly limited, making it suitable for specific types of critical systems, large traditional software systems, or certain embedded systems where inflexibility is tolerable.)(D)

--------------------------------------------------------------------------------
(2_SW Processes.pdf)(Contrast the core operational differences between a Plan-driven process and an Agile process in terms of planning, change accommodation, and process flow.)(A) (Plan-driven processes rely on incremental planning and find it easy to rapidly adjust the underlying process to evolving customer requirements, whereas Agile processes stipulate that all activities are planned meticulously in advance and progress is strictly measured against that predefined schedule.)(B) (In Agile processes, the stages of specification, development, and validation are performed separately and sequentially, prioritizing upfront detailed documentation, while Plan-driven processes interleave these activities, minimizing documentation in favor of working code deliverables.)(C) (Plan-driven processes mandate that all development activities are rigidly planned beforehand, and iteration typically occurs only within individual activities, while Agile processes adopt incremental planning and are structured explicitly to accommodate changing requirements at a relatively low cost.)(D) (Agile processes are exclusively focused on building stand-alone applications using commercial off-the-shelf components, ensuring maximal reuse, while Plan-driven processes are generally reserved for developing embedded control systems where bespoke code generation is mandatory.)(C)

--------------------------------------------------------------------------------
(2_SW Processes.pdf)(Incremental development offers several distinct benefits over the traditional Waterfall approach. Analyze how this model effectively addresses the challenges associated with accommodating change and customer interaction.)(A) (It resolves the problem of system structure degradation by ensuring that time and money are always allocated to refactoring every system version, simultaneously addressing the issue of management visibility by mandating comprehensive documentation for every rapid increment.)(B) (It facilitates more rapid delivery and deployment of useful software, allowing customers to gain value earlier, and significantly reduces the cost of accommodating changing requirements because less analysis and documentation are required to be redone compared to the sequential Waterfall model.)(C) (Incremental development mandates that all system requirements be fully defined and frozen before the start of the first increment, thus stabilizing the development process and preventing customer feedback from unduly influencing the architecture of later, critical components.)(D) (The core benefit is maximizing technical efficiency by focusing development effort primarily on non-functional requirements like security and reliability, while postponing the delivery of functional customer-facing features until the very final, large-scale increment is ready for deployment.)(B)

--------------------------------------------------------------------------------
(2_SW Processes.pdf)(The Integration and Configuration process model heavily relies on software reuse. Explain the process stages involved and the inherent risk this approach introduces regarding user needs.)(A) (The stages involve detailed requirements specification followed by meticulous component adaptation and integration, focusing entirely on developing bespoke software units; the risk is the substantial time delay caused by developing everything from scratch, which compromises rapid delivery.)(B) (Key stages are Requirements Specification, Software Discovery and Evaluation of components, Requirements Refinement based on available components, and Configuration or Adaptation/Integration; the risk is that compromises are inevitable, meaning the final system may not perfectly meet the real, underlying needs of the users.)(C) (The process is centered around extensive stakeholder consultation during validation to ensure compliance with existing software platforms, avoiding any reusable elements; the risk is the high cost associated with building complex web services when equivalent stand-alone components are already commercially available.)(D) (The approach mandates developing software components only for local systems, explicitly forbidding the integration of web services or components built for frameworks like .NET or J2EE; the resulting risk is a complete loss of control over the system's evolution because reused elements are externally managed.)(B)

--------------------------------------------------------------------------------
(2_SW Processes.pdf)(Software validation is a crucial activity in the software process. Detail the primary purpose of Verification and Validation (V&V) and the different testing stages commonly employed to achieve this goal.)(A) (The goal of V&V is solely to demonstrate system defects by executing it with obscure, abnormal test data, ensuring it fails catastrophically; the stages include only Component testing and Alpha testing, excluding system-level checks or customer involvement.)(B) (The goal of V&V is to establish that a system conforms to its specification and meets the actual requirements of the customer, involving validation through program testing, checking processes, and system testing, which includes component, system, and final customer (acceptance) testing stages.)(C) (The primary purpose of V&V is to check the initial feasibility of the product backlog and refine the requirements based on available reusable components, and the common stages involve Architectural design, Database design, and Interface design prior to any coding activity.)(D) (V&V aims to prove that all development costs are strictly less than expected evolution costs, thereby optimizing the economic viability of the project; the stages consist solely of Component testing followed immediately by Operation and Maintenance, bypassing requirements analysis entirely.)(B)

--------------------------------------------------------------------------------
(2_SW Processes.pdf)(In the context of managing inevitable change in large software projects, explain the complementary relationship between Change Anticipation and Change Tolerance as strategies to reduce the costs associated with rework.)(A) (Change Anticipation involves designing the process so changes are accommodated cheaply using methods like incremental delivery, while Change Tolerance means proactively incorporating activities like system prototyping to predict potential changes before significant rework is needed.)(B) (Change Tolerance mandates freezing all requirements once development begins, thereby completely avoiding change, while Change Anticipation means implementing rapid prototyping languages to ensure high execution performance, regardless of how often customer demands shift.)(C) (Change Anticipation involves incorporating specific activities into the software process, such as system prototyping, to predict changes early, and Change Tolerance means designing the process, perhaps through incremental delivery, so that necessary changes can be absorbed at a relatively low cost.)(D) (Change Anticipation relies entirely on developing comprehensive documentation for every phase to minimize future confusion, whereas Change Tolerance exclusively applies to embedded systems, allowing them to adjust dynamically to changing hardware platforms without requiring new code.)(C)

--------------------------------------------------------------------------------
(2_SW Processes.pdf)(The Capability Maturity Model (CMM) uses maturity levels to reflect the adoption of good technical and management practices. Contrast the characteristics of the Initial level with the Optimizing level.)(A) (The Initial level is the highest level, where the organization uses statistical and quantitative methods to control all subprocesses, whereas the Optimizing level is characterized by ad-hoc processes where only the scope of work is communicated to team members.)(B) (At the Initial level, processes are unpredictable and reactive, but the goals associated with the process area are satisfied, and the scope of work is explicitly set out; the Optimizing level, conversely, is the highest level where process and product measurements are actively used to drive continuous process improvement.)(C) (The Optimizing level focuses on organizational standardization and deploying processes adapted from a defined set of organizational templates, while the Initial level requires organizational policies to be in place defining when each process should be used.)(D) (Both levels require documented project plans and mandatory resource management procedures across the institution, but the Optimizing level focuses specifically on ensuring all software documentation is minimized to support rapid agile development methods, which is not true for the Initial level.)(B)

--------------------------------------------------------------------------------
(2_SW Processes.pdf)(What are the potential drawbacks associated with using a prototype, even if it successfully aids requirements elicitation and design exploration, and why are prototypes generally recommended to be 'thrown away' rather than used as the basis for a production system?)(A) (Drawbacks include the high cost of developing the prototype and the risk that developers will spend too much time tuning it for non-functional requirements; they should be kept because they always meet normal organizational quality standards better than final systems.)(B) (A problem is that users may not interact with the prototype in the same way they would with the final system, and a prototype is usually discarded because it is typically undocumented, its structure is degraded by rapid change, and it may fail to meet normal quality standards or non-functional requirements.)(C) (Prototypes are fundamentally flawed because they prevent rapid prototyping languages from being used, forcing dependence on slow, traditional development methods; they must be thrown away because they inherently lack functional system requirements and cannot demonstrate application concepts.)(D) (The main risk is that the prototype always includes too much functionality, delaying its delivery schedule unnecessarily, and it must be discarded because it explicitly includes sophisticated error handling and memory utilization features which impede rapid design exploration.)(B)

--------------------------------------------------------------------------------
(2_SW Processes.pdf)(Incremental delivery involves breaking down system development and delivery into parts, with higher priority requirements included in early increments. What are the main challenges that make incremental delivery problematic, especially when replacing existing systems or adhering to traditional procurement models?)(A) (It is inherently difficult to ensure that the process maintains the benefits of incremental development, as incorporating changes into the system becomes increasingly complex, and the initial, higher priority system services receive minimal required testing, degrading overall quality.)(B) (The main problem arises because all requirements must be defined in detail upfront and frozen before the start of the project, conflicting with the iterative nature of specification inherent in incremental delivery, making it unsuitable for rapid change accommodation.)(C) (It becomes challenging when replacing an existing system because early increments may have less functionality than the system being replaced, and it conflicts with procurement models where a complete system specification is required as part of the development contract before work commences.)(D) (The process necessitates that large systems, especially those developed by globally distributed teams, must wait until the entire system is developed before customers can gain any value, negating the central advantage of rapid feedback and continuous evaluation.)(C)

--------------------------------------------------------------------------------
(2_SW Processes.pdf)(Explain the distinction between the two primary approaches to software process improvement: the process maturity approach and the agile approach, considering their respective focuses.)(A) (The process maturity approach focuses on organizational standardization and iterative development, aiming to reduce all bureaucratic overheads, while the agile approach centers on improving process and project management through implementing good software engineering practice.)(B) (The agile approach focuses primarily on developing detailed project plans and documenting resource management procedures across the institution, whereas the process maturity approach is geared towards rapid delivery of functionality and high responsiveness to changing customer requirements.)(C) (The process maturity approach is centered on introducing good management practices and improving process maturity levels (like CMM), emphasizing predictable processes, while the agile approach focuses on reducing overheads through iterative development and minimizing documentation to achieve rapid delivery and responsiveness.)(D) (Both approaches share the same immediate goal: to mandate the use of the Waterfall model for all large-scale systems, but the process maturity approach emphasizes system validation through testing, and the agile approach emphasizes early system specification.)(C)

--------------------------------------------------------------------------------
(3_Agile SW Dev.pdf)(Identify and explain the central tenet of the Agile Manifesto regarding documentation and customer interaction, and how these values contrast with traditional plan-driven methodologies.)(A) (The Agile Manifesto values comprehensive documentation over working software and contract negotiation over customer collaboration, reflecting the plan-driven emphasis on fixed, detailed specifications and legally binding contracts developed prior to implementation.)(B) (The Agile Manifesto values working software over comprehensive documentation and customer collaboration over contract negotiation, signifying a preference for frequent delivery of executable code and close stakeholder involvement over extensive paperwork and rigid contractual agreements.)(C) (Agile methods prioritize following a plan over responding to change and processes and tools over individuals and interactions, adhering to the principles of strict adherence to upfront planning and the use of formalized, mandatory development tools.)(D) (Traditional plan-driven methods favor incremental delivery and embracing change by using simple, adaptable designs, while Agile methods strictly require a complete, single-delivery approach based on fully detailed system specifications defined at the outset.)(B)

--------------------------------------------------------------------------------
(3_Agile SW Dev.pdf)(Extreme Programming (XP) promotes several core practices, including Refactoring and Test-first development. Explain the rationale behind adopting these practices, particularly concerning system structure and verification.)(A) (Refactoring is conventionally practiced by designing extensively for anticipated future changes, spending significant upfront time to minimize eventual costs, while Test-first development is adopted primarily to ensure non-functional requirements like security are fully implemented before functional coding begins.)(B) (Refactoring involves constant code improvement to keep the software simple and maintainable, avoiding the structural decay common during change, and Test-first development requires writing automated tests before writing the functionality, clarifying requirements and reducing problems from interface misunderstandings.)(C) (Test-first development is used to generate copious amounts of detailed documentation to satisfy regulatory requirements, while Refactoring is used only when development pressure allows, typically delayed until the final stages of the project to minimize disruption to the established code architecture.)(D) (Refactoring is limited to tidying up variable names and attributes, and specifically forbids reorganizing class hierarchies or removing duplicate code, and Test-first development focuses on generating tests as data rather than executable programs, thus ensuring manual execution is always necessary.)(B)

--------------------------------------------------------------------------------
(3_Agile SW Dev.pdf)(In Extreme Programming, how is the requirements specification managed, and what is the role of the customer representative in this process?)(A) (Requirements are managed through detailed, formal system specifications generated during a distinct requirements engineering phase, and the customer representative's role is strictly limited to signing off on the final contract documentation, having no involvement in daily development tasks or testing.)(B) (Requirements are captured as user stories (scenarios of use) written on cards, which the development team breaks down into implementation tasks; the customer is expected to be an on-site member of the team, prioritizing stories for inclusion in frequent, small system releases.)(C) (The customer is only involved in negotiating the contract, ensuring payment terms are met, while the requirements are exclusively defined by the ScrumMaster based on their expert assessment of market demands, prioritizing features that support continuous integration rather than immediate business value.)(D) (All requirements are defined by the development team using complex Architectural Description Languages (ADLs) to maximize design precision, and the customer's interaction is limited to providing highly formalized test plans during the final system acceptance testing phase, conducted off-site.)(B)

--------------------------------------------------------------------------------
(3_Agile SW Dev.pdf)(Pair programming is a core XP practice where two developers work together at one computer. Explain the dual roles assumed during this practice and the primary advantages it brings to the development team, particularly concerning knowledge transfer.)(A) (The roles are Planner and Documenter, where one maps out the long-term project schedule while the other writes comprehensive formal specifications; the main advantage is increasing overall project risk by concentrating specialized knowledge into isolated pairs.)(B) (The roles are ScrumMaster and Product Owner, where one facilitates the daily meeting and the other prioritizes the product backlog items; the advantage is that it enforces strict adherence to the defined plan, preventing unnecessary code refactoring and maintaining high velocity.)(C) (The roles are Driver (writing code) and Navigator/Observer (reviewing code line-by-line and considering strategic direction); this practice serves as an informal review process, encourages refactoring, spreads knowledge across the team, and helps develop common ownership of the code base.)(D) (Pair programming is highly inefficient, significantly reducing overall team productivity because it forces two programmers to work only on tactical aspects of the current task; the only minor benefit is ensuring that all tests fail immediately when new functionality is introduced.)(C)

--------------------------------------------------------------------------------
(3_Agile SW Dev.pdf)(Agile methods have proven highly successful for small, co-located teams. Discuss the key practical problems encountered when attempting to scale up agile methods to develop large systems or scale out across large, established organizations.)(A) (Scaling up is easy because large systems are always greenfield developments, perfectly suited for incremental change, and scaling out poses no issues since large organizations always lack internal quality procedures and welcome the immediate reduction in necessary documentation.)(B) (Agile's informality conflicts with the legal requirements of contract definition in large companies; they are often better suited for new development rather than maintenance, which constitutes the majority of costs; and they struggle with distributed, worldwide teams that cannot rely on informal, constant communication.)(C) (The main problem is that agile methods necessitate continuous integration, which is strictly forbidden in large organizations due to strict regulatory controls; scaling up requires the introduction of multiple Product Owners, which violates the core Agile principle of maintaining simplicity.)(D) (Scaling out introduces the problem that system architects collaborate too closely, leading to overly detailed documentation which slows down development, and scaling up eliminates the possibility of customer involvement, as large systems generally have no identifiable stakeholders or end-users.)(B)

--------------------------------------------------------------------------------
(3_Agile SW Dev.pdf)(In contexts where a plan-driven approach might be required due to system characteristics, how does the expected system lifetime and external regulation influence the decision regarding process choice?)(A) (If the system has a long expected lifetime, a full agile approach is mandated to ensure maximum flexibility for evolution, and external regulation strongly favors reduced documentation, relying solely on automated test results for safety assurance.)(B) (Long system lifetimes often necessitate detailed documentation to effectively communicate developer intentions to future support teams, suggesting a plan-based approach, and regulated systems frequently require detailed documentation to be produced as part of the formal system safety case or compliance evidence.)(C) (External regulation mandates the use of continuous integration and pair programming to achieve compliance, irrespective of system type, and expected lifetime is irrelevant as modern agile techniques eliminate all needs for maintenance or long-term support documentation.)(D) (Plan-driven methods should only be used for short-lifetime systems, minimizing initial investment, whereas regulatory requirements automatically enforce the use of test-first development in all circumstances, regardless of the system's size or type.)(B)

--------------------------------------------------------------------------------
(3_Agile SW Dev.pdf)(Why does the lack of a definitive statement of requirements, inherent in interleaved agile development, create a significant problem regarding contractual relationships between a customer and a supplier in large projects?)(A) (The absence of comprehensive documentation means that the customer cannot provide any feedback on the software increments, forcing the supplier to rely exclusively on complex architectural design decisions made during the initial planning phase.)(B) (Since the requirements evolve alongside the code, there is no fixed, definitive specification document available to serve as the agreed-upon, legally binding component of the contract, compelling the customer to pay for development time rather than the delivery of a specific feature set.)(C) (The problem is resolved by the use of Velocity metrics, which precisely quantify the amount of functionality delivered per sprint, allowing the customer to measure progress accurately against the total planned budget, irrespective of requirement changes.)(D) (Agile methods require that the contract strictly forbids the use of existing systems or legacy components, ensuring that all code is developed bespoke, leading to potential legal disputes if the supplier attempts to incorporate any pre-existing software libraries or frameworks.)(B)

--------------------------------------------------------------------------------
(3_Agile SW Dev.pdf)(Analyze the practical challenges large organizations face when trying to implement the Agile Principle of Customer Involvement, particularly when external stakeholders or complex organizational structures are present.)(A) (Customer Involvement is difficult because the customer representative must strictly limit their time spent with the development team, prioritizing high-level management tasks, and external stakeholders, like regulators, are always forbidden from having their views represented to the agile team.)(B) (This principle relies on having a customer who is both willing and able to dedicate time to the development team and accurately represent all system stakeholders; difficulties arise when customer representatives have conflicting time demands or when external regulatory stakeholders need their views integrated into the agile process.)(C) (The main issue is that customer representatives often demand far too much documentation, conflicting with the agile value of working software over comprehensive documentation, forcing the team to revert to a plan-driven process to meet these demands.)(D) (Customer involvement is only practical for small product development teams; in large organizations, the process mandates the creation of a 'Scrum of Scrums' meeting, ensuring that the customer's input is mediated solely by the ScrumMasters, thus limiting direct access to developers.)(B)

--------------------------------------------------------------------------------
(3_Agile SW Dev.pdf)(In the Scrum framework, describe the distinction between the Product Backlog and the Sprint Backlog, and clarify whose responsibility it is to manage the content and detail of the primary list.)(A) (The Sprint Backlog is the complete, high-level list of all required product features and improvements for the entire project lifecycle, while the Product Backlog contains only the specific tasks selected for immediate, focused development during a single, fixed-length iteration; the ScrumMaster manages both.)(B) (The Product Backlog is a comprehensive, prioritized list of all work (features, requirements, improvements) that needs to be addressed by the team, and it is the responsibility of the Product Owner to define and maintain the appropriate level of detail; the Sprint Backlog is the subset of items selected for the current sprint.)(C) (The Product Backlog only includes high-priority functional requirements, excluding non-functional aspects like architecture definition or user documentation, which are exclusively reserved for the Sprint Backlog; the Development Team has collective ownership and responsibility for prioritizing all items.)(D) (Both backlogs are identical lists maintained simultaneously to ensure redundancy, but the Product Backlog is written in English, and the Sprint Backlog must be translated into a formal, executable language; neither list changes once the initial outline planning phase is complete.)(B)

--------------------------------------------------------------------------------
(3_Agile SW Dev.pdf)(How does the organizational structure of a Scrum development team, including the role of the ScrumMaster, facilitate focused development during a sprint, and what is the function of the daily Scrum meeting?)(A) (The ScrumMaster acts as the traditional project manager, dictating tasks and enforcing rigid adherence to the original plan, while the team is deliberately integrated with external management during the sprint to maximize transparency; the daily meeting is a long session dedicated to resolving complex technical disputes.)(B) (The ScrumMaster is a facilitator who ensures the process is followed and isolates the self-organizing team from outside interference; the daily Scrum meeting is a short, face-to-face event where team members share progress, identify problems, and re-plan the work for the immediate future.)(C) (The development team is explicitly forbidden from self-organizing and must rely on the Product Owner to assign specific coding tasks; the daily meeting is held monthly and serves only to measure the team's Velocity against the total product backlog effort remaining.)(D) (During the sprint, all team communication is channeled through the Product Owner, who is responsible for writing all the code; the daily meeting is strictly reserved for stakeholders to review the potentially shippable product increment delivered from the preceding iteration.)(B)

--------------------------------------------------------------------------------
(3_Agile SW Dev.pdf)(Describe the concept of 'Velocity' in Scrum and explain its practical utility for the development team during the sprint cycle planning process.)(A) (Velocity is a mandatory metric used to enforce contractual compliance, ensuring that all originally specified requirements are met by the final deadline, regardless of how often the product backlog is reprioritized or changes occur during the sprints.)(B) (Velocity is an abstract representation of the ratio between development costs and anticipated long-term evolution costs, exclusively used by the ScrumMaster to calculate resource allocation for the next annual budget cycle.)(C) (Velocity is an estimate quantifying the amount of product backlog effort that a team can realistically complete within the duration of a single sprint; understanding a team's velocity is crucial as it helps the team accurately estimate what functionality can be selected from the product backlog for implementation in the next sprint.)(D) (Velocity is the measure of the time difference between the development platform and the execution platform, ensuring host-target communication latency is minimized; it provides a basis for assessing how effectively the team avoids the practice of pair programming throughout the project.)(C)

--------------------------------------------------------------------------------
(3_Agile SW Dev.pdf)(A project manager in a traditional, plan-driven organization is concerned about adopting Scrum because it involves delivering a potentially shippable product increment. What is the key meaning and inherent challenge associated with ensuring an increment meets this 'potentially shippable' standard?)(A) (It means the increment has been fully documented using traditional design models like UML state diagrams and sequence charts, but the challenge is that these documents must be generated after the sprint concludes, leading to inevitable documentation lag.)(B) (It implies that the software increment must be developed using throw-away prototypes that are intentionally undocumented to speed up development, but the challenge is that customers might mistake these prototypes for the final system, leading to unrealistic expectations.)(C) (It signifies that the increment is in a finished state, requiring no further work like testing or integration before it could theoretically be incorporated into the final product; however, in practice, achieving this true finished state for every increment is often difficult or impossible.)(D) (The standard requires that the increment includes only non-functional requirements and must be developed using a repository architecture to maintain centralized data control; the challenge is that the Product Owner must strictly forbid the development team from communicating with external stakeholders.)(C)

--------------------------------------------------------------------------------
(4_Architectural design.pdf)(The software architecture of a system significantly influences its non-functional characteristics. Explain how architectural decisions related to layer structuring and component redundancy specifically address the non-functional requirements of Security and Availability.)(A) (Availability is ensured by using a pipe and filter model, where functional transformations process data sequentially, while Security is addressed by minimizing communications and using large, coarse-grained components to reduce interface complexity.)(B) (Security is primarily achieved by using a layered architecture, placing critical assets and security features deep within the inner layers to control access, and Availability is enhanced by including redundant components and implementing fault tolerance mechanisms to ensure continuous operation.)(C) (Both Security and Availability are achieved by distributing all components across a complex network using the Client-Server pattern, making critical services single points of failure, which maximizes the impact of denial of service attacks.)(D) (Security requires that safety-critical features be spread across as many sub-systems as possible to maximize analysis complexity, and Availability is only concerned with responsiveness and processing time, making component redundancy an irrelevant design factor.)(B)

--------------------------------------------------------------------------------
(4_Architectural design.pdf)(Differentiate between Architecture in the small and Architecture in the large, and explain why explicitly defining a software architecture offers significant advantages related to system analysis.)(A) (Architecture in the large concerns the decomposition of an individual program into components, whereas Architecture in the small deals with complex enterprise systems incorporating multiple systems; explicit definition is advantageous because it facilitates the development of automated testing tools like JUnit.)(B) (Architecture in the small relates to how an individual program is decomposed into components, while Architecture in the large concerns the structure of complex enterprise systems that integrate multiple programs and systems; explicit definition enables system analysis, particularly allowing evaluation of whether the system can meet its critical non-functional requirements.)(C) (Architecture in the small refers to systems designed for long-term evolution and maintenance, requiring maximum documentation, while Architecture in the large refers to throw-away prototypes intended solely for requirements elicitation, minimizing documentation and focusing only on functional aspects.)(D) (Explicit architecture is critical for compliance with the GNU General Public License (GPL) licensing requirements, but it severely limits large-scale reuse; Architecture in the small is the only view that supports stakeholder communication using informal block diagrams.)(B)

--------------------------------------------------------------------------------
(4_Architectural design.pdf)(The Model-View-Controller (MVC) pattern separates system data management, presentation, and user interaction. Analyze the conditions under which this pattern is most effectively used and describe its main advantage concerning data representation.)(A) (MVC is best used when systems contain simple data models and straightforward user interactions, as it minimizes code complexity; its advantage is that it ties the data model rigidly to a single presentation format, ensuring consistency across distributed server implementations.)(B) (MVC is useful when multiple ways to view and interact with data are required, or when future presentation and interaction requirements are unknown; its primary advantage is allowing the system data to change independently of its visual representation, and vice versa, while supporting multiple simultaneous displays of the same data.)(C) (The pattern is exclusively suitable for compiler design and language processing systems, where the Abstract Syntax Tree must be shared among all filters; its advantage is minimizing resource utilization by enforcing a sequential data processing flow through all components.)(D) (MVC should be used only for highly embedded control systems where interaction is minimal and data is centrally managed in a single Repository; its advantage is reducing development risk by forbidding the use of automated testing frameworks during the implementation phase.)(B)

--------------------------------------------------------------------------------
(4_Architectural design.pdf)(Detail the purpose and typical usage scenarios for the Layered Architecture pattern, and explain why providing clean separation between the layers can be difficult in practice.)(A) (Layered Architecture models the interfacing of subsystems, organizing functionality into layers that provide services to the layer immediately above; it is used when building new facilities on top of existing systems or when multi-level security is required; difficulty arises because high-level layers often need to bypass immediate layers to interact directly with lower-level core services.)(B) (The pattern is primarily used to manage data flow in non-interactive batch processing systems, strictly enforcing a sequence where data must pass through every layer sequentially, thereby preventing performance degradation; separation is difficult because redundant facilities like authentication must be provided in every layer.)(C) (Layered Architecture is mandated for systems requiring maximum performance optimization, achieved by allowing core layers to access user interface layers directly without restriction; separation is maintained easily because all components communicate exclusively through a central data repository, eliminating the need for inter-layer communication.)(D) (It is an architectural style used exclusively for stand-alone applications that run on local computers without network access, ensuring system portability by localizing all machine dependencies in the outermost layer; separation is hard because multiple versions of the user interface must be maintained simultaneously.)(A)

--------------------------------------------------------------------------------
(4_Architectural design.pdf)(Explain the Repository Architecture pattern, its core advantages regarding data management, and the crucial disadvantage that poses a threat to the entire system.)(A) (Repository Architecture structures the system as sequential functional transformations (filters) processing data streams, ensuring high component independence; the advantage is transformation reuse, but the disadvantage is the high overhead of agreeing on a common data transfer format between transformations.)(B) (In this pattern, data exchange occurs through explicit communication between sub-systems, each maintaining its own private database; the advantage is high performance due to data distribution, but the disadvantage is the inability to integrate off-the-shelf software components.)(C) (All data is managed in a central repository accessible to all system components, which do not interact directly with each other; advantages include consistent data management (e.g., backups) and component independence; however, the repository is a single point of failure, meaning problems within it affect the whole system.)(D) (Repository Architecture uses a network to allow clients to access distributed servers for services like printing; the advantage is that servers do not need to know the client identities; the disadvantage is that this structure is easily susceptible to denial-of-service attacks due to unpredictable network performance.)(C)

--------------------------------------------------------------------------------
(4_Architectural design.pdf)(The Client-Server architectural pattern describes a distributed system model. Identify its major components and explain the primary advantage of this model regarding distribution and functionality.)(A) (The components are the single, central Repository, the Language Processing System, and the Compiler’s Symbol Table; the advantage is that it prevents the system from being implemented on a single computer, mandating physical distribution for high security compliance.)(B) (The major components include a set of stand-alone servers providing specific services (like data management), a set of clients accessing these services, and a network facilitating client access; the primary advantage is its inherently distributed architecture, allowing general functionality to be made available to all clients without needing repetitive implementation.)(C) (Components consist of the Model, the View, and the Controller, implemented using a relational database; the advantage is the absolute guarantee that performance will be highly predictable because it exclusively relies on a reliable local network protocol that eliminates all single points of failure.)(D) (The system consists of the Architectural Design Decisions, the Project Management Framework, and the System Acceptance Test Plan; the advantage is that clients must always know the identity of all other clients accessing the service, ensuring maximum security and data integrity.)(B)

--------------------------------------------------------------------------------
(4_Architectural design.pdf)(Language Processing Systems (LPS), such as compilers, often rely on a Repository Architecture or a Pipe and Filter Architecture. If a compiler uses a Pipe and Filter approach, how does this specifically affect the structure, and what is the associated trade-off regarding data transfer efficiency?)(A) (The Pipe and Filter model requires the LPS to operate exclusively as a distributed client-server system, forcing components like the lexical analyzer and syntax analyzer to execute in parallel, thus maximizing efficiency but demanding constant, informal communication between all filters.)(B) (It organizes the processing so that functional transformations (filters) sequentially process input to produce output, suitable for batch processing, but the required trade-off is that an agreed-upon data transfer format is needed, increasing system overhead because each transformation must parse its input and unparse its output.)(C) (This architecture requires the LPS to integrate all components through a central Symbol Table (repository), where components do not interact directly; the trade-off is the inability to manage data consistently, forcing all backups and archival processes to be handled separately by each individual component.)(D) (The Pipe and Filter model is exclusively suitable for interactive, transaction-based systems, enabling rapid user interaction; the trade-off is that it severely limits the system’s ability to reuse functional transformations because data structures are often incompatible and cannot be easily translated.)(B)

--------------------------------------------------------------------------------
(4_Architectural design.pdf)(Information Systems commonly use a layered architecture. Identify the typical layers in such a system and explain why this architecture is highly suitable for managing transactions and complexity.)(A) (The core layers are the Component Testing layer, the Acceptance Testing layer, and the User Testing layer, which ensures system validation; this model is suitable because it strictly separates verification activities from validation activities, minimizing integration errors.)(B) (The layers include the User Interface, User Communications, Information Retrieval, and the System Database; this layered structure is highly suitable because it organizes the system functionality logically, making management of database transactions and asynchronous user requests efficient and modular.)(C) (The layers must follow the Model-View-Controller pattern, requiring all security protocols to be placed in the outermost layer; this architecture is suitable because it completely eliminates the need for detailed specification, prioritizing code flexibility over rigid documentation.)(D) (Information systems are characterized by monolithic, non-distributed architectures comprising only two layers: the Hardware Platform and the Abstract Machine Code layer; this approach maximizes performance by minimizing communication overhead and complexity.)(B)

--------------------------------------------------------------------------------
(5_Implementation.pdf)(In the Object-Oriented Design (OOD) process, why is the step of defining the System Context and External Interactions considered essential before moving on to designing the system architecture?)(A) (Defining the system context is necessary only if the team decides to use the Waterfall model, as agile approaches inherently disregard external constraints in favor of rapid internal iteration and prototyping.)(B) (Understanding the system's relationships with its external environment and associated systems is crucial because it informs decisions about the required system functionality, helps structure the system for communication with that environment, and allows the designer to accurately establish the system boundaries.)(C) (This step is solely dedicated to selecting the final programming language and defining all object attributes at the implementation level, ensuring maximum reuse of open-source libraries, thereby accelerating the deployment schedule regardless of customer needs.)(D) (The context model's sole purpose is to identify which objects must be undocumented to meet the requirements of the GNU General Public License (GPL), forcing the design to comply with strict, reciprocal licensing restrictions across all development platforms.)(B)

--------------------------------------------------------------------------------
(5_Implementation.pdf)(Object identification is described as an iterative process that relies on skill and domain knowledge. If a designer uses a scenario-based approach for the Weather Station system, what types of objects are likely to be identified initially, and why is this method effective?)(A) (Scenario analysis primarily identifies "implementation objects" used to provide general services like error handling and memory management, but it is ineffective for identifying application domain objects (like Ground thermometer or Weather data) because it lacks grammatical description.)(B) (The scenario-based approach is effective because it forces the identification of objects, attributes, and methods participating in the use-case interaction; initially identified objects are often based on tangible entities like hardware instruments (Anemometer, Barometer) and key data structures (Weather data).)(C) (This method exclusively identifies high-level "System of Systems" objects that require integration across distributed networks, strictly prohibiting the identification of simple, localized objects that only run on the local development platform, such as the Weather station's interface object.)(D) (Scenario-based analysis is only useful for designing the inheritance hierarchy by grouping implementation objects into logical packages, but it cannot be used to refine or extend initial object identification, which must rely on highly formalized design pattern descriptions.)(B)

--------------------------------------------------------------------------------
(5_Implementation.pdf)(During OOD, Design Models are created, categorized as Structural (static) and Behavioral (dynamic). Explain the information conveyed by Sequence Models and State Machine Models.)(A) (Sequence models are structural, showing how the design is organized into logical groups of encapsulated packages, while State Machine models are static, illustrating the inheritance relationships between object classes and associated methods.)(B) (Sequence models are dynamic models that demonstrate the sequence of interactions (service requests) between objects over time, arranged vertically; State Machine models are also dynamic, showing how individual objects alter their state in direct response to defined external events and service requests.)(C) (State Machine models show the overall system architecture and the distribution of components across processors, making them structural, while Sequence models show the logical grouping of objects into subsystems using UML package notation, making them static models.)(D) (Both models are inherently structural: Sequence models detail the system hardware requirements for configuration management, and State Machine models specify the precise, low-level binary interface definitions necessary for Host-Target development and debugging activities.)(B)

--------------------------------------------------------------------------------
(5_Implementation.pdf)(The Observer design pattern separates the display of an object's state from the object managing the state. Describe the problem this pattern solves and the primary consequence related to optimization.)(A) (The Observer pattern solves the problem of how to ensure the object managing the state (ConcreteSubject) knows all the specific implementation details of every display format (ConcreteObserver); the consequence is that it leads to excessive coupling, making the system difficult to maintain.)(B) (It solves the problem of needing multiple displays of state information, especially when those displays may not be known upfront, and ensuring all presentations update automatically when the state changes; the consequence of this separation is that optimizations to enhance display performance become impractical.)(C) (This pattern is used to provide a standard way of accessing elements in a collection, irrespective of how the collection is implemented; the consequence is that it severely restricts the ability of the system to manage its data consistently through a centralized repository architecture.)(D) (The Observer pattern solves the problem of configuring an application system for multiple platforms; the primary consequence is that it mandates the use of non-reciprocal licenses (like BSD), thereby preventing the use of open-source components licensed under the GPL.)(B)

--------------------------------------------------------------------------------
(5_Implementation.pdf)(Software reuse is now a standard approach to development. Contrast the characteristics of The abstraction level of reuse with The system level of reuse, according to the source material.)(A) (The abstraction level involves directly reusing entire application systems that require adaptation and configuration to meet user needs, while the system level involves reusing knowledge about successful abstract designs and applying those ideas to new software development.)(B) (The abstraction level means reusing executable components (like components or object classes) directly from a library, bypassing the need for writing original code, while the system level means reusing only non-functional system attributes like performance and dependability metrics.)(C) (The abstraction level means reusing knowledge of successful abstractions in design, rather than reusing software directly; the system level involves reusing entire application systems, which must be adapted and tailored to specific customer requirements, often encompassing commercial off-the-shelf (COTS) products.)(D) (Both levels are primarily concerned with ensuring the software complies with external regulatory standards; the abstraction level applies to systems using open-source licensing, while the system level applies exclusively to proprietary software systems that prohibit any form of customization.)(C)

--------------------------------------------------------------------------------
(5_Implementation.pdf)(Configuration Management (CM) is essential in a collaborative development environment. Describe the main objective of CM and list two crucial supporting activities.)(A) (The main objective is to eliminate all forms of software change and complexity throughout the development lifecycle; crucial activities include Test-first development and Refactoring, ensuring that all code is written optimally before version tracking begins.)(B) (The main objective is to support the system integration process, allowing all developers controlled access to code and documents, tracking changes, and enabling component compilation/linking to create systems; two supporting activities are Version Management (tracking component versions) and System Integration (defining which component versions form a system release).)(C) (The main objective is to dictate the use of only non-reciprocal open-source licenses (LGPL, BSD) to maximize profitability; two supporting activities include Interface Specification and Architectural Design, ensuring the system is strictly limited to monolithic architectures.)(D) (The objective is to ensure that development platform tools, like IDEs, are never used, forcing developers to rely exclusively on command-line compilation; supporting activities are Debugging (finding faults) and Testing (establishing the existence of defects) without automated tools.)(B)

--------------------------------------------------------------------------------
(5_Implementation.pdf)(Host-Target development is common in software engineering. Explain the distinction between the host and target systems and provide examples of tools typically found on the development platform (host).)(A) (The host system is the platform where the production software will execute (e.g., an embedded device), and the target system is the environment where the software is developed; tools include the final deployment script and acceptance testing environment.)(B) (The host system is where the software is developed (Development Platform), and the target system is the separate machine where the software executes (Execution Platform), particularly common in embedded or mobile systems; host tools include integrated compilers, language debugging systems, and configuration management tools.)(C) (Both platforms are identical hardware systems running the same operating system and supporting software; the host platform is distinguished only by its exclusive use of throw-away prototypes, while the target platform only runs the final, fully tested production code.)(D) (The host platform is defined by its use of the GNU General Public License (GPL) for all components, while the target platform uses proprietary, closed-source licenses; tools on the host platform are limited to those supporting manual testing and complex documentation generation.)(B)

--------------------------------------------------------------------------------
(5_Implementation.pdf)(Contrast the licensing requirements and permissions of the GNU General Public License (GPL) with the Berkley Standard Distribution (BSD) License in the context of open source software reuse.)(A) (GPL is a non-reciprocal license, meaning users are not obliged to publish changes, and it can be included in proprietary systems sold as closed source; BSD is reciprocal, forcing any new system using its code to also be fully open source.)(B) (GPL is a reciprocal license, meaning if open source software licensed under GPL is used in a new system, that new system must also be made open source; BSD is a non-reciprocal license, allowing users to include the code in proprietary, closed-source systems without being required to republish their changes.)(C) (Both licenses are identical and interchangeable, specifically designed to be highly compatible with traditional plan-driven development models, thereby avoiding the need for continuous refactoring or pair programming practices.)(D) (GPL requires all software development to occur exclusively on a Linux operating system, forbidding Windows or macOS usage, while BSD only applies to embedded systems and explicitly excludes all web-based or cloud-based service implementations.)(B)

--------------------------------------------------------------------------------
(6_Testing.pdf)(Program testing is defined as executing a program with artificial data to find defects. What crucial limitation must be acknowledged regarding the ultimate purpose of testing, and how does this limitation contrast with the goal of Validation Testing?)(A) (The crucial limitation is that testing can definitively prove the absence of errors, guaranteeing system correctness before release; this contrasts with Validation Testing, which aims to deliberately expose defects by using obscure and abnormal test data.)(B) (The critical limitation is that testing can only reveal the presence of errors, not their definitive absence; Validation Testing aligns with the goal of demonstrating that the software meets its requirements by performing correctly using test cases that simulate expected, normal system use.)(C) (Testing is limited to uncovering errors only in the low-level machine code and cannot address defects in requirements or design documentation; Validation Testing is therefore concerned solely with checking component compatibility and component interface problems, excluding non-functional requirements.)(D) (The only limitation is that testing must be conducted manually using test plans generated by an independent team; this is contrary to Validation Testing, which is performed solely by the development team through continuous integration and automated test harnesses.)(B)

--------------------------------------------------------------------------------
(6_Testing.pdf)(Software Inspections (static verification) and Software Testing (dynamic verification) are complementary V&V techniques. What is the fundamental advantage of inspections over testing, particularly concerning incomplete system versions and error masking?)(A) (Inspections require the execution of the system with simulated data, making them more time-consuming than testing, but their advantage is that they can definitively check the system's non-functional characteristics like performance and usability.)(B) (Inspections are performed on the static source code or documentation before implementation and do not require system execution; their key advantage is that errors cannot mask (hide) other errors, and they can be applied to incomplete versions of a system without the need to develop specialized test harnesses.)(C) (Testing provides the sole advantage of allowing evaluation of broader quality attributes like compliance with standards and portability, whereas inspections are limited to locating defects caused by interface misuse and timing errors in multithreaded systems.)(D) (Inspections are primarily concerned with checking conformance with the customer's real requirements, which testing cannot achieve, but they suffer the disadvantage of requiring significant additional costs to inspect any components that are not fully developed.)(B)

--------------------------------------------------------------------------------
(6_Testing.pdf)(Development Testing includes Unit Testing, Component Testing, and System Testing. Explain the respective focus of Unit Testing and System Testing during the development lifecycle.)(A) (Unit testing focuses on testing the integration of separately developed components, checking for emergent system behavior, whereas System testing focuses exclusively on testing individual program units or object classes in strict isolation from all other components.)(B) (Unit testing is the process of testing individual components (like object classes or methods) in isolation, focusing on the functionality of objects; System testing involves integrating components to test the system as a whole, focusing on the interactions between components and emergent system behavior.)(C) (Unit testing is primarily conducted by the customer using test cases derived from scenarios, while System testing is a manual process performed by an independent team using test data based on abnormal inputs derived from the specification of real data.)(D) (Both stages focus equally on testing component interfaces, but Unit testing occurs after the final acceptance testing, verifying that all changes have been correctly implemented, while System testing focuses only on non-functional requirements such as security and scalability.)(B)

--------------------------------------------------------------------------------
(6_Testing.pdf)(Test-Driven Development (TDD) inter-leaves testing and code development. Detail the TDD process activities and explain how this approach fundamentally benefits debugging.)(A) (TDD mandates that code is written first, followed by a separate phase where a test is developed for that code increment, which is run only once; this process accelerates debugging by deliberately introducing 'test-lag' to maximize code coverage.)(B) (The process involves identifying a small functionality increment, writing and implementing an automated test for it (which initially fails), implementing the functionality, and rerunning all previous and new tests until successful; this approach simplifies debugging because when a test fails, the problem is immediately localized to the small chunk of newly written code.)(C) (TDD requires developing all system functionality in a single, large increment without prior testing; debugging is simplified because the entire development team collaboratively engages in continuous refactoring until all high-level system requirements are met, irrespective of component isolation.)(D) (TDD is only effective for reusing large legacy systems and is ineffective for new code development; the process activities focus on generating comprehensive documentation before coding begins, and debugging is achieved by outsourcing the testing process to a separate, independent team.)(B)

--------------------------------------------------------------------------------
(6_Testing.pdf)(User Testing encompasses Alpha testing, Beta testing, and Acceptance testing. Explain the purpose and key operational difference between Beta testing and Acceptance testing.)(A) (Beta testing is performed by the system developers at the developer's site, working closely with users to find problems; Acceptance testing is used solely for generic software products and is the final stage before code is transferred back to the development team for maintenance.)(B) (Beta testing involves making a system release available to a selected group of early adopter customers so they can experiment and find interaction problems in their operational environment, serving also as a marketing tool; Acceptance testing is primarily for custom systems, where customers formally test the system to decide whether it is ready to be deployed and accepted from the developers.)(C) (Acceptance testing is the initial stage where use cases are defined and test cases are derived from sequence diagrams, occurring before any code is written; Beta testing is the final stage where the customer signs the contract, agreeing to pay for all development time regardless of system functionality.)(D) (Both testing types are structurally identical and are reserved for embedded control systems; Beta testing checks for component interface misuse, while Acceptance testing checks for timing errors in shared memory systems that operate across distributed networks, requiring full visibility of the code.)(B)

--------------------------------------------------------------------------------
(6_Testing.pdf)(Interface Testing is crucial for composite components. Identify the primary objective of Interface Testing and describe one type of interface error it aims to detect.)(A) (The objective is to test whether individual methods within a component conform to their functional specification; it detects errors where developers have incorrectly applied the concept of pair programming, leading to insufficient documentation for the public interest.)(B) (The objective is to detect faults resulting from interface errors or invalid assumptions made about interfaces; one type of error is Interface Misuse, where a calling component uses the interface incorrectly (e.g., passing parameters in the wrong order or type), or Interface Misunderstanding, where incorrect assumptions are made about the behavior of the called component.)(C) (The objective is solely to check non-functional emergent properties like performance and reliability in a stress testing scenario; it detects errors where external regulation guidelines were not meticulously followed during the initial requirements analysis phase of the project.)(D) (The objective is to generate all possible error messages, ensuring the user interface is fully robust; it detects errors where all reusable software components were not correctly licensed under the GNU Lesser General Public License (LGPL), risking legal disputes with open-source contributors.)(B)

--------------------------------------------------------------------------------
(6_Testing.pdf)(Scenario testing is an approach used during release testing. Explain the nature of a scenario test and clarify why this method is effective for identifying multiple requirement issues simultaneously.)(A) (A scenario test is a brief, isolated unit test designed to check one specific functional transformation by passing data sequentially through a pipe and filter system, making it suitable for verifying single requirements in isolation.)(B) (A scenario test is a credible, often complex, narrative story that describes a typical usage of the system; this method is highly effective because running through the narrative forces interactions between multiple system components, allowing several requirements, and their interdependencies, to be tested within the same scenario.)(C) (A scenario test is a simulated denial-of-service attack designed to deliberately overload the system during stress testing, thereby revealing component interface faults; it is effective because it targets non-functional requirements such as security and maintainability, ignoring functional use cases.)(D) (A scenario test is a detailed architectural design diagram generated using UML, representing the system structure prior to coding; it is ineffective for requirement issues but crucial for communicating complexity between the development team and external management stakeholders.)(B)

--------------------------------------------------------------------------------
(6_Testing.pdf)(In the context of the Mentcare patient information system, how does Requirements Based Testing (RBT) ensure that the system adequately handles the critical functional requirement concerning drug allergies, and what specific action must be tested?)(A) (RBT mandates setting up a patient record with every possible known allergy in the database, requiring the system to automatically calculate the lowest possible efficiency rating for system performance during data retrieval, irrespective of any warnings issued.)(B) (RBT involves systematically deriving tests for each requirement; regarding allergies, it mandates tests where a patient with a known allergy is prescribed the corresponding medication, checking that the system correctly issues a warning message, and ensuring that if the prescriber overrules the warning, the system requires a documented reason.)(C) (RBT requires testing only the scenario where a patient has no known allergies, and the system must be tested to ensure it never issues a warning, as this would violate the core principles of rapid delivery and acceptable system usage, according to the Scrum framework.)(D) (RBT requires that all system documentation must be written before any testing is conducted, meaning the allergy check requirement is only validated using static inspection techniques, excluding any dynamic execution or system testing until the final release stage.)(B)

--------------------------------------------------------------------------------
(6_Testing.pdf)(System Testing focuses on component interactions and emergent behavior. When a complex system is developed using reusable components and off-the-shelf systems, what is the crucial difference between the focus of the initial Unit/Component testing phase and the final System Testing phase?)(A) (Unit/Component testing focuses exclusively on high-level security features and interface compatibility, ensuring that all third-party modules can communicate with proprietary code, whereas System Testing concentrates on the functionality of individual, isolated methods.)(B) (Unit/Component testing is concerned with verifying that each individual object or component interface behaves according to its localized specification, assuming other units are correct; System Testing, conversely, checks that integrated components are mutually compatible, interact correctly, and transfer the right data at the right time across all interfaces, checking the emergent behavior of the whole.)(C) (System Testing is always an individual activity performed by the lead programmer, whereas Unit/Component testing is a collective process requiring collaboration between the independent testing team and the customer representative to establish acceptance criteria before development begins.)(D) (The difference is negligible, as both stages focus primarily on testing for timing errors and interface misuse in message passing systems, ensuring that stress testing guidelines are fully integrated into the regression test suite for continuous execution.)(B)

--------------------------------------------------------------------------------
(1_Introduction.pdf)(Which of the following scenarios presents a situation where the failure to utilize established software engineering methods would most critically impact both the financial investment and the long-term reliability of the resulting system?)(A) (A small, personal programming project developed by a hobbyist intending to use the system locally for a short duration, where immediate functionality is prioritized over rigorous documentation and maintainability standards.)(B) (A large manufacturing company, whose core products and services have evolved to require sophisticated software control systems for critical production lines, decides to develop complex embedded software internally without implementing systematic specification, validation, or evolution processes.)(C) (A web-based system designed exclusively for entertainment purposes, where the development team relies heavily on iterative development and prototyping to deliver rich interfaces quickly, intentionally minimizing upfront documentation and detailed specification phases.)(D) (A safety-critical control system that requires a complete, analyzable specification developed before any coding begins, where the team adheres to best-practice methods but chooses a prototype-based approach to expedite the verification of non-functional requirements.)(B)

--------------------------------------------------------------------------------
(2_SW Processes.pdf)(In the context of software requirements, explain the necessary difference in detail levels required by End-users and customers versus System developers during the specification activity.)(A) (System developers need an abstract, high-level statement of constraints and goals to manage budget and schedule, while end-users and customers require an extremely detailed system specification using formal modeling techniques to ensure all functional components are precisely defined.)(B) (End-users and customers typically require a high-level statement detailing the services and goals of the system they intend to use, whereas system developers require a much more detailed and precise system specification to translate those needs into an executable design and implementation plan.)(C) (End-users only need to see the final, compiled program and are not involved in defining requirements at all, while system developers only work with the generalized process model (like Waterfall) and do not concern themselves with low-level details provided in a specific system specification.)(D) (Both groups require identical, medium-level detail: neither too abstract nor too implementation-specific, ensuring that the specification remains flexible enough to accommodate continuous changes driven by iterative development, minimizing the need for upfront feasibility studies or market analysis.)(B)

--------------------------------------------------------------------------------
(3_Agile SW Dev.pdf)(Agile methods, despite their benefits, may require a different procurement model. If a customer is accustomed to a plan-driven contract based on a fixed set of requirements, how must the contract model change to accommodate an agile process where requirements are continually evolving?)(A) (The customer must agree to a strict, non-negotiable fixed-price contract defined by the final product backlog list, and the supplier must guarantee that no changes will be introduced after the conclusion of the initial high-level architectural design phase, regardless of customer feedback.)(B) (The contract must shift away from demanding delivery of a specific, static set of requirements and move towards a model where the customer pays for the time required for system development, reflecting the inherent flexibility and continuous iteration fundamental to agile methods where the final specification is discovered incrementally.)(C) (The contract must explicitly mandate the use of the Repository architecture pattern and the Observer design pattern to ensure system performance is maximized, and it must forbid the use of test-first development as a verification technique, prioritizing static inspection instead.)(D) (Agile methods eliminate the need for any formal contracts; the relationship is based entirely on informal communication between the on-site customer and the ScrumMaster, relying solely on shared moral obligation rather than legal definitions of deliverables.)(B)

--------------------------------------------------------------------------------
(4_Architectural design.pdf)(In the context of the iLearn system, which uses a layered architecture, how does the localization of machine dependencies within this pattern specifically enhance the system's portability and support for multi-platform implementations?)(A) (Layered architecture places machine dependencies in the highest layer (User Interface), meaning platform changes only affect core services, guaranteeing performance degradation across all implementations.)(B) (The pattern allows for incremental development and localizes machine dependencies, concentrating them within specific layers, which means that when the system needs to be deployed on a new platform, only those specific layers containing the dependencies need modification or replacement, thus enhancing portability.)(C) (iLearn's architecture forbids the separation of machine dependencies, forcing them to be distributed across all functional components, which maximizes the complexity of updating the system whenever a service-oriented component is replaced by a newer version.)(D) (The layered structure mandates the use of highly specialized hardware for execution, making multi-platform implementation impossible; portability is only relevant for the system's ability to seamlessly integrate with proprietary closed-source application systems.)(B)

--------------------------------------------------------------------------------
(5_Implementation.pdf)(Interface specification is crucial for parallel component design. Why is it important that designers do not include details of the data representation in an interface design, and what must be included instead?)(A) (Including data representation details is necessary to comply with the BSD license, ensuring the system can be sold as closed source; designers must include the system's final architectural design diagrams in the interface to show how all components are distributed across the network.)(B) (Data representation details must be omitted because they prematurely commit the design to a specific implementation that might need to change later, thereby reducing flexibility; instead, the interface should define the necessary operations required to access and update the encapsulated data.)(C) (Designers must include all information about external component licensing and intellectual property rights to protect the employer's interests, and they must exclude all abstract method signatures, focusing exclusively on non-functional requirements like memory utilization and response time.)(D) (The interface must only include the complete sequence diagram detailing all run-time interactions between objects, as specifying operations or data access methods would compromise the system's ability to maintain a simple, abstract design model.)(B)

--------------------------------------------------------------------------------
(6_Testing.pdf)(Testing strategies often include Partition Testing. Explain the concept of an equivalence partition and how selecting test cases from these partitions contributes to effective testing.)(A) (An equivalence partition is a segment of the source code that must be covered by a unit test to achieve 100% code coverage, and selecting tests from here ensures that the test harnesses are fully automated using tools like JUnit.)(B) (An equivalence partition is a group of inputs or output results that share common characteristics, meaning the program should behave in an equivalent way for every member within that class; selecting tests from each partition ensures systematic coverage of input domains and often catches errors programmers make at the boundaries of these domains.)(C) (Equivalence partitions are exclusive to white-box testing and mandate testing with sequences of zero length and negative inputs; selecting tests from these partitions prevents the use of mock objects and external simulators during host-target development.)(D) (An equivalence partition is a segment of the project management plan that defines which requirements are highest priority for incremental delivery, and selecting tests from these partitions helps the Product Owner calculate the team's Velocity metric for the next sprint.)(B)

--------------------------------------------------------------------------------
(1_Introduction.pdf)(The increasing complexity of software systems is identified as a major factor in project failure. How does the reliance on new software engineering techniques paradoxically contribute to increasing demands on system complexity, and what new capabilities are consequently required?)(A) (New techniques mandate the use of the Waterfall model, which increases complexity by requiring all phases to be completed linearly, resulting in demands for systems that must strictly avoid any integration with web services or distributed technologies.)(B) (New software engineering techniques enable the construction of larger and more complex systems, which in turn leads to changing demands, specifically requiring systems to be delivered more quickly, to be even larger and more intricate, and to possess new capabilities previously considered technologically impossible.)(C) (The use of these techniques simplifies development to the point where complexity is reduced, but this simplification introduces ethical issues related to computer misuse and intellectual property rights, demanding stricter adherence to non-functional requirements over functionality.)(D) (Advanced techniques ensure that all system complexity is localized within the core hardware platform, allowing the software component to remain simple and independent, primarily demanding that all future system evolution must be performed exclusively through automatic refactoring.)(B)

--------------------------------------------------------------------------------
(2_SW Processes.pdf)(System prototyping is an essential activity for coping with change. If an organization decides to use prototyping for requirements elicitation, what explicit steps must be taken to manage the objectives and functionality of the prototype to ensure its cost-effectiveness and timely delivery?)(A) (The objectives must be left implicit to allow for maximum design flexibility, and the prototype must include sophisticated error handling and full implementation of all non-functional requirements (like security and reliability) to ensure it serves as a robust foundation for the final production system.)(B) (Prototype objectives, such as validating functional requirements or developing the user interface, must be made explicit from the start, and to reduce costs and accelerate delivery, functionality may be omitted, and non-functional requirements (like response time or error handling) may be relaxed or ignored.)(C) (The prototype development process must strictly adhere to the plan-driven model, forbidding any incremental or agile methods, and the objective must solely be focused on demonstrating the application to senior managers, excluding input from end-users or system customers.)(D) (Prototyping must include time-consuming documentation generation, focusing on areas already well-understood, and the objectives must mandate the use of slow, traditional programming languages to minimize the risk that the evaluators might adjust their behavior due to rapid response times.)(B)

--------------------------------------------------------------------------------
(3_Agile SW Dev.pdf)(Scrum mandates that sprints are fixed length (usually 2-4 weeks). What is the critical advantage of fixing the sprint length, and how does this approach manage unstable requirements compared to a process where iteration length is variable?)(A) (Fixed length sprints accommodate unstable requirements by allowing the scope of the sprint to expand indefinitely if new requirements emerge, ensuring that the team always works until the entire product backlog is completed, regardless of time elapsed.)(B) (Fixing the sprint length provides a consistent rhythm and helps the team accurately measure their Velocity over time, which improves future planning; unstable requirements are managed because, once a sprint starts, the requirements selected for that iteration are frozen, but requirements for later increments can continue to evolve.)(C) (Fixed length sprints mandate that the customer must be isolated from the development team during the sprint, preventing any communication or feedback, thereby stabilizing the requirements by force until the next cycle begins.)(D) (Fixed length sprints are problematic because they severely restrict the team's ability to introduce continuous integration, forcing all testing to be performed manually during the project closure phase, thus hindering the management of unstable requirements.)(B)

--------------------------------------------------------------------------------
(4_Architectural design.pdf)(If a system architect is primarily concerned with maximizing the system's Maintainability, what key architectural decision, regarding component structure and size, would be most effective, and why does this decision support long-term change?)(A) (The architect should utilize a monolithic, tightly coupled system structure with extremely large, coarse-grain components, as this localizes all critical operations and minimizes component interfaces, thereby simplifying the overall system analysis required for future support.)(B) (The most effective decision is to prioritize the use of fine-grain, replaceable components organized using principles that allow the data representation to change independently of the component's functionality, because smaller, interchangeable units are inherently easier to modify, update, and replace in response to changing needs.)(C) (The focus must be on using only components that rely on shared memory interfaces, eliminating all parameter passing, because this approach ensures that all safety-critical features are isolated in inner layers, regardless of the system's overall structure or complexity.)(D) (To maximize maintainability, the system must exclusively implement the Pipe and Filter pattern, forcing all data processing components to execute sequentially in a batch mode, as this eliminates the need for any formal documentation regarding future evolution intentions.)(B)

--------------------------------------------------------------------------------
(5_Implementation.pdf)(When a software development team decides to use a Commercial Off-the-Shelf System (COTS) instead of writing all the code from scratch, how does this build or buy decision fundamentally redefine the focus and priorities of the subsequent design process?)(A) (The design process shifts entirely to developing robust automated test harnesses and extensive unit tests for every method in the COTS product, as the primary goal becomes uncovering all pre-existing defects in the bought system before implementation can begin.)(B) (The design process shifts its focus from identifying and realizing complex object classes and their relationships in a conventional programming language, to concentrating on how to use and configure the existing features of the COTS system to successfully deliver the specified requirements.)(C) (The team must revert to a plan-driven, Waterfall model, as COTS integration is fundamentally incompatible with agile methods, requiring the development of highly detailed UML sequence models and state diagrams for every potential run-time interaction.)(D) (The decision mandates that the design must adhere to reciprocal open-source licensing, forcing the COTS vendor to immediately publish the source code of their proprietary system, leading to a focus on maximizing the system's efficiency and responsiveness for a single, target execution platform.)(B)

--------------------------------------------------------------------------------
(6_Testing.pdf)(Regression testing is essential in iterative and incremental development processes where changes are frequent. Explain the purpose of regression testing and why test automation is critical for making this activity cost-effective.)(A) (The purpose is to verify the initial software specification against the customer's high-level requirements, and automation is critical because it ensures that testing is performed exclusively by an independent team using manual test plans, preventing developer bias.)(B) (Regression testing checks that recent changes or additions to the code base have not inadvertently broken functionality that was previously working correctly; test automation is critical because, unlike expensive manual testing, automated tests can be quickly and easily rerun automatically every time a change is committed to the program, making frequent verification cost-effective.)(C) (The goal is to intentionally overload the system (stress testing) to determine its failure behavior under extreme conditions, and automation is achieved by deploying throw-away prototypes that intentionally lack error handling mechanisms to expedite fault detection.)(D) (The purpose is solely to measure the team's velocity and efficiency metrics throughout the sprint cycle, and automation is required to generate the comprehensive documentation needed for the project closure phase, which is mandated by the SEI CMM Level 5 maturity process.)(B)

--------------------------------------------------------------------------------
(1_Introduction.pdf)(Software engineering ethics requires professionals to behave honestly and responsibly. Which responsibility area mandates that engineers must protect client and employer proprietary information, regardless of whether a formal agreement exists, and which area governs the necessary protection of third-party patents and copyrights?)(A) (The responsibility area of Competence governs respecting confidentiality and proprietary information, while the area of Computer Misuse covers the protection of third-party intellectual property rights.)(B) (The responsibility area of Confidentiality requires engineers to respect the confidentiality of employers or clients, even without a formal agreement, and Intellectual Property Rights governs the awareness and protection of local laws concerning patents and copyright.)(C) (Both responsibilities are covered under the single ethical principle of PUBLIC, which requires acting consistently with the public interest, meaning all internal proprietary information must be released publicly to maximize the health, safety, and welfare of the community.)(D) (The responsibility of Efficiency dictates that all software must be reusable, making confidentiality irrelevant, and the responsibility of Acceptability governs ensuring that all source code is always fully available for modification by the end-user, regardless of legal agreements.)(B)

--------------------------------------------------------------------------------
(2_SW Processes.pdf)(In the design process, which specific activity involves identifying the overall system structure, defining its principal components (modules/subsystems), and specifying their relationships and distribution?)(A) (Interface Design, which defines the precise boundaries and protocols for communication between individual methods and object classes to enable parallel implementation efforts.)(B) (Component Selection and Design, which is solely concerned with searching external libraries for reusable components that can fulfill specific functional requirements defined in the specification.)(C) (Database Design, which focuses exclusively on defining the internal data structures of the system and how they are ultimately represented and managed within the persistent storage system.)(D) (Architectural Design, where the system's overall structure is identified, and the principal components, their relationships, and how they are distributed across the system environment are established.)(D)

--------------------------------------------------------------------------------
(3_Agile SW Dev.pdf)(The XP practice of Collective Ownership allows any developer to change anything in the code. What is the key objective of this practice, and how does it mitigate the risk of developing "islands of expertise" within the team?)(A) (The objective is to strictly limit access to the source code to only senior pair programmers, minimizing the chances of incorrect code modifications; it mitigates risk by requiring all code changes to be approved by the ScrumMaster before continuous integration can occur.)(B) (The objective is to ensure that all developers share responsibility for the entire code base; it mitigates the risk of isolated expertise by ensuring that developers work in dynamic pairs across all areas of the system, spreading knowledge and avoiding situations where only one person understands a critical component.)(C) (The objective is to maintain strict adherence to non-functional requirements by forbidding any refactoring during the sprint; it mitigates risk by ensuring that the on-site customer is fully responsible for all code changes related to user stories.)(D) (The objective is to delay integration as long as possible until the final system release is complete, prioritizing long-term design stability; it mitigates risk by guaranteeing that the team's velocity remains constant throughout the project lifecycle, regardless of external interference.)(B)

--------------------------------------------------------------------------------
(4_Architectural design.pdf)(Architectural models are often criticized when using simple, informal block diagrams. What is the fundamental criticism leveled against these diagrams, despite their utility in communication and project planning?)(A) (The fundamental criticism is that they inherently force the system to adopt a Client-Server architecture, making them unsuitable for embedded control systems that require local operation and synchronous execution flows.)(B) (The criticism is that they completely lack semantics, meaning they fail to clearly show the explicit types of relationships that exist between the entities, nor do they adequately represent the visible, non-functional properties of the entities contained within the architecture.)(C) (The criticism is that they require excessive detail, often forcing the architectural design process to slow down significantly, conflicting with the rapid iteration demands of agile development and leading to premature commitment to implementation technologies.)(D) (The diagrams are criticized because they are the exclusive notation of the SEI CMM Level 1 (Initial) maturity model, and their use immediately signals that the development team is failing to employ good software engineering practices like refactoring and test-first development.)(B)

--------------------------------------------------------------------------------
(5_Implementation.pdf)(The OOD process involves identifying principal objects, followed by developing design models. In a plan-based development process, what level of detail is typically required in these models, and how does this requirement differ from an agile approach?)(A) (In a plan-based process, outline design models sketched on a whiteboard are sufficient, as specific decisions are made during implementation; agile methods require highly detailed models derived from abstract models to ensure all distributed teams have a common, documented understanding.)(B) (Plan-based processes usually require more detailed models derived from high-level abstract models, ensuring that all team members have a documented, common understanding before coding begins; agile development often relies only on outline design models, with specific decisions delegated to the programmers during implementation.)(C) (Both processes require the exact same level of detail, focusing only on the Behavioral (dynamic) models like sequence charts, but the plan-based approach forbids the use of structural models that might define class hierarchies or generalization relationships.)(D) (The level of detail is determined solely by the chosen open-source license; GPL mandates highly abstract models, while BSD requires the inclusion of complete data representation details in all static models to maximize the proprietary nature of the final system.)(B)

--------------------------------------------------------------------------------
(6_Testing.pdf)(In Test-Driven Development (TDD), the creation of a regression test suite is a continuous byproduct of the development process. Explain what a regression test suite is and how TDD makes the management of this suite efficient.)(A) (A regression test suite is the collection of all documentation generated during the software specification phase, and TDD manages it efficiently by ensuring all documents are published under the same Creative Commons license.)(B) (A regression test suite is the set of tests used to check that changes have not introduced defects into previously working code; TDD makes its management efficient because the suite is developed incrementally alongside the program, and since all tests are automated, they can be rerun quickly and automatically every time new functionality is added, ensuring continuous quality assurance.)(C) (The test suite is a collection of all non-functional requirements defined during the architectural design phase; TDD manages it efficiently by forcing all developers to manually execute every test case before the daily Scrum meeting, irrespective of whether new code was written.)(D) (The regression test suite is a proprietary list of known defects and interface misunderstandings found in commercial off-the-shelf (COTS) components, and TDD manages it by requiring the development team to use only mock objects that simulate catastrophic system failure scenarios.)(B)

--------------------------------------------------------------------------------
(1_Introduction.pdf)(Given that expenditure on software represents a significant fraction of GNP in all developed countries, what is the core economic justification for adopting robust software engineering methods and techniques over simply treating development as a personal programming project?)(A) (The justification is that advanced software engineering methods allow development teams to minimize costs by exclusively using complex assembly language programming, eliminating the need for high-level language compilers and interpreters.)(B) (The core justification is the economic observation that using software engineering methods is usually cheaper in the long run, principally because for most systems, the majority of costs incurred over the system's lifetime are the high costs associated with changing the software after it has already been put into use (evolution and maintenance).)(C) (Adopting these methods is justified because they guarantee the system will be delivered within two weeks, ensuring extremely rapid deployment, which overrides all considerations of long-term maintainability or security requirements.)(D) (The justification centers around the fact that software engineering methods rigorously enforce the separation of development (60% cost) and testing (40% cost), preventing cost overruns in the initial development phase by limiting stakeholder communication.)(B)

--------------------------------------------------------------------------------
(2_SW Processes.pdf)(Software evolution involves modifying existing software due to changing customer and market requirements. Why has the traditional distinction between development and evolution (maintenance) become increasingly irrelevant in modern software engineering?)(A) (The distinction is irrelevant because modern systems are now exclusively developed using the Waterfall model, where evolution is formally defined as the final, separate stage, ensuring maximum control over system changes and bug correction.)(B) (The distinction is fading because fewer and fewer systems developed today are entirely new systems; most projects involve modifying and integrating with existing software systems, making the continuous modification of code and requirements a standard rather than a post-development phase.)(C) (The blurring of lines is due to the mandatory use of the SEI CMM Level 1 maturity model, which requires all process activities (specification, development, validation) to be performed by a single individual, eliminating the need for separate managerial activities.)(D) (Evolution is now defined exclusively as the process of developing throw-away prototypes for requirements elicitation, a phase that only occurs before the system is put into practical use, thus separating it clearly from the initial development phase which focuses on system validation.)(B)

--------------------------------------------------------------------------------
(3_Agile SW Dev.pdf)(Agile project management, particularly Scrum, demands a high degree of transparency and shared knowledge. How does the concept of Velocity contribute to this transparency and help the team measure improving performance over time?)(A) (Velocity measures the efficiency of the ScrumMaster in isolating the team from external interference, contributing to transparency by publishing all confidential external communications to the Product Backlog daily.)(B) (Velocity provides an estimate of how much product backlog effort the team can cover in a sprint; by tracking this measure across successive sprints, the team and stakeholders gain visibility into the team's capacity and can measure quantifiable improvements in performance and productivity over the project duration.)(C) (Velocity is a mandatory metric that requires the development team to produce comprehensive documentation during the sprint; transparency is ensured because this documentation must align strictly with the initial requirements defined in the traditional plan-driven contract.)(D) (Velocity calculates the exact number of user stories that were discarded or modified during the sprint, and transparency is achieved by only sharing this negative information with the on-site customer, concealing it from external management stakeholders.)(B)

--------------------------------------------------------------------------------
(4_Architectural design.pdf)(Transaction processing systems, such as e-commerce systems, must ensure the integrity of the database is maintained. What characteristic defines a transaction from a user's perspective, and what system component processes these user requests?)(A) (From a user perspective, a transaction is defined as any operation that requires a complete system architecture refactoring; these requests are processed by the System Testing team during the final acceptance validation phase, ensuring no unexpected interactions occur.)(B) (A user transaction is defined as any coherent sequence of operations that satisfies a goal (e.g., finding flight times), and all operations must complete before changes are permanent; these asynchronous requests are managed and processed by a specialized transaction manager within the system's architecture.)(C) (A transaction is defined as a non-functional requirement related to security compliance, requiring all user data to be encrypted using the Observer pattern; these requests are handled by the system's lexical analyzer, which processes user intentions expressed in a formal language.)(D) (A transaction is characterized by the sequential flow of data through multiple filters, typical of a Pipe and Filter architecture; these requests are handled by the Configuration Services, which are used to adapt the system environment for specific sets of application services.)(B)

--------------------------------------------------------------------------------
(5_Implementation.pdf)(In an Integrated Development Environment (IDE), how does the grouping of software development tools support efficiency, and which essential tools related to development testing and quality assurance are typically included?)(A) (IDEs group tools to force developers to rely solely on manual code editing and debugging without automation, which maximizes intellectual rigor; essential tools included are only the final release management system and the customer acceptance testing protocols.)(B) (IDEs group tools within a common framework and user interface, supporting different aspects of development (e.g., for a specific language like Java); essential tools include an integrated compiler, a language debugging system, testing tools (like Junit for automated tests), and configuration management tools.)(C) (IDEs primarily serve to enforce compliance with open-source licensing, ensuring that no proprietary code is accidentally introduced; they only include tools for designing UML state diagrams and sequence models, strictly excluding any direct programming support.)(D) (IDEs only include visualization and program analysis tools necessary for understanding the code of reusable COTS components, but they exclude all development tools, as coding is expected to be done outside the environment on the target execution platform.)(B)

--------------------------------------------------------------------------------
(6_Testing.pdf) (Alpha testing is a type of user testing. Where does Alpha testing typically occur, who participates, and what benefit does it provide that is often missed during internal development testing?) (A) (Alpha testing occurs in the system's final operational environment, involving a large, external group of early adopter customers; it primarily provides marketing feedback and assesses the system's interaction problems with external network architecture.) (B) (Alpha testing occurs at the developer's site, where users of the software work directly with the development team; it provides the benefit of identifying problems and issues that are not immediately apparent to the internal testing team, given their specialized perspective on the system.) (C) (Alpha testing is conducted by an independent team to ensure all code is properly refactored and complies with the design principles of the MVC pattern; it benefits the project by defining the final acceptance criteria required for the completion of the contractual agreement.) (D) (Alpha testing is mandated for systems using a plan-driven process where requirements are frozen upfront; its benefit is solely to check that the system meets its high-level non-functional requirements such as efficiency and reliability under extreme stress testing conditions.) (B)
