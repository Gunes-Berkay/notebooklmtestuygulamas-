# app.py
from flask import Flask, jsonify, request, Response
import sqlite3
import os
from pathlib import Path
from to_db import sanitize_table_name, insert_questions_from_txt, create_table_if_not_exists

DB_FILE = "database.db"
TESTS_DIR = "tests"

app = Flask(__name__, static_folder=None)

# Helper: list tables (user-created quiz tables)
def list_quiz_tables():
    if not os.path.exists(DB_FILE):
        return []
    conn = sqlite3.connect(DB_FILE)
    cur = conn.cursor()
    cur.execute("SELECT name FROM sqlite_master WHERE type='table'")
    rows = cur.fetchall()
    conn.close()
    # exclude sqlite internal tables if any
    tables = [r[0] for r in rows if not r[0].startswith("sqlite_")]
    return tables

# Helper: get questions from a table
def get_questions_from_table(table_name):
    table_name = sanitize_table_name(table_name)
    conn = sqlite3.connect(DB_FILE)
    cur = conn.cursor()
    try:
        cur.execute(f"SELECT question, A, B, C, D, correct, source FROM \"{table_name}\"")
        rows = cur.fetchall()
    except Exception as e:
        rows = []
    conn.close()
    # return as list of dicts
    questions = []
    for r in rows:
        questions.append({
            "question": r[0],
            "A": r[1],
            "B": r[2],
            "C": r[3],
            "D": r[4],
            "correct": r[5],
            "source": r[6] if len(r) >= 7 else ""
        })
    return questions

@app.route("/api/tables", methods=["GET"])
def api_tables():
    tables = list_quiz_tables()
    return jsonify({"tables": tables})

@app.route("/api/load_from_txt", methods=["POST"])
def api_load_from_txt():
    """
    Expect JSON: {"filename": "6_Testing.txt"}
    File should exist in tests/ folder.
    This endpoint will call to_db.insert_questions_from_txt(...)
    """
    data = request.get_json() or {}
    filename = data.get("filename", "")
    if not filename:
        return jsonify({"error": "filename required"}), 400
    path = Path(TESTS_DIR) / filename
    if not path.exists():
        return jsonify({"error": "file not found in tests/"}), 404
    table_name = path.stem
    try:
        inserted = insert_questions_from_txt(str(path), DB_FILE, table_name)
        return jsonify({"ok": True, "inserted": inserted, "table": table_name})
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@app.route("/api/questions/<table_name>", methods=["GET"])
def api_questions(table_name):
    table = sanitize_table_name(table_name)
    questions = get_questions_from_table(table)
    if not questions:
        return jsonify({"error": "table not found or has no questions"}), 404
    return jsonify({"table": table, "count": len(questions), "questions": questions})

# Serve single-page app (inline HTML)
@app.route("/", methods=["GET"])
def index():
    html = """<!doctype html>
<html lang="tr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Smart Quiz - Web</title>
<style>
    :root{
        --bg:#121212; --card:#1f1f1f; --muted:#aaa; --accent:#388e3c; --danger:#d32f2f; --btn:#2e2e2e;
    }
    html,body{
        height:100%;
        margin:0;
        background:var(--bg);
        color:#fff;
        font-family: "Segoe UI", Roboto, Arial, sans-serif;
    }
    .app{
        min-height:100vh;
        display:flex;
        flex-direction:column;
        padding:30px 60px;
        box-sizing:border-box;
    }
    .topbar{
        display:flex;
        align-items:center;
        gap:16px;
    }
    .score{
        font-weight:700;
        font-size:22px;
    }
    select, button.load{
        background:var(--card);
        color:#fff;
        border:1px solid #333;
        padding:10px 14px;
        border-radius:8px;
        font-size:16px;
    }
    .sourceLabel{ color:var(--muted); margin-top:10px; font-size:15px; }
    .question{
        margin-top:28px;
        text-align:center;
        font-size:28px;
        line-height:1.15;
    }

    /* options container */
    .options{
        margin-top:36px;
        display:flex;
        flex-direction:column;
        gap:24px;
        align-items:center;
        flex:1 1 auto;
        justify-content:center;
    }

    .opt{
        width:85vw;               /* daha geniş */
        max-width:1300px;
        min-width:650px;
        background:var(--btn);
        border:3px solid #444;    /* biraz kalın kenarlık */
        border-radius:18px;       /* köşeler daha yumuşak */
        padding:28px 30px;        /* daha fazla iç boşluk */
        box-sizing:border-box;
        cursor:pointer;
        display:flex;
        align-items:center;
        justify-content:center;
        text-align:center;
        color:#fff;
        font-size:28px;           /* yazı boyutu büyüdü */
        font-weight:500;
        user-select:none;
        -webkit-user-select:none;
        transition:transform .08s ease, background .12s ease;
        white-space:normal;
        overflow-wrap:break-word;
        word-break:break-word;
        line-height:1.3;
    }

    /* mobil için */
    @media (max-width: 768px) {
        .opt {
            width:95%;
            min-width:auto;
            font-size:22px;
            padding:24px 20px;
        }
    }

    /* masaüstü için */
    @media (min-width: 769px) {
        .opt {
            width:80%;
            font-size:32px;
            padding:30px 25px;
        }
    }

    .opt:active{ transform:scale(.995); }

    .next-row{
        display:flex;
        justify-content:flex-end;
        margin-top:28px;
    }
    .btn-next{
        padding:14px 22px;
        font-size:18px;
        border-radius:10px;
        background:var(--card);
        border:1px solid #333;
        color:#fff;
        cursor:pointer;
    }

    /* coloring for correct/wrong */
    .correct{ background:var(--accent) !important; border-color:rgba(56,142,60,.9) !important; }
    .wrong{ background:var(--danger) !important; border-color:rgba(211,47,47,.9) !important; }

    /* responsive tweaks */
    @media (max-width: 768px) {
        .option-button {
            width: 95%;
            height: 100px;
            font-size: 20px;
        }
    }

    @media (min-width: 769px) {
        .option-button {
            width: 80%;
            height: 150px;
            font-size: 32px;
        }
    }

    /* small helper */
    .muted{ color:var(--muted); font-size:13px; margin-left:8px; }
</style>
</head>
<body>
<div class="app">
    <div class="topbar">
        <div class="score">Skor: <span id="score">0</span></div>
        <div style="flex:1"></div>
        <label>
            <select id="tableSelect"></select>
        </label>
        <button class="load" id="btnLoad">Soruları Getir</button>
        <button class="load" id="btnImport" title="Tests klasöründen .txt yükle (dosya adı ile)">TXT'den Yükle</button>
    </div>

    <div class="sourceLabel" id="sourceLabel"></div>

    <div class="question" id="question">Yüklemek için bir test seçip "Soruları Getir"e bas.</div>

    <div class="options" id="options">
        <div class="opt" data-key="A" id="optA">A şıkkı</div>
        <div class="opt" data-key="B" id="optB">B şıkkı</div>
        <div class="opt" data-key="C" id="optC">C şıkkı</div>
        <div class="opt" data-key="D" id="optD">D şıkkı</div>
    </div>

    <div class="next-row">
        <button class="btn-next" id="nextBtn" disabled>Sonraki Soru</button>
    </div>
</div>

<script>
(async function(){
    const tableSelect = document.getElementById('tableSelect');
    const btnLoad = document.getElementById('btnLoad');
    const btnImport = document.getElementById('btnImport');
    const scoreSpan = document.getElementById('score');
    const questionEl = document.getElementById('question');
    const sourceLabel = document.getElementById('sourceLabel');
    const nextBtn = document.getElementById('nextBtn');
    const optionsContainer = document.getElementById('options');
    const optEls = {
        A: document.getElementById('optA'),
        B: document.getElementById('optB'),
        C: document.getElementById('optC'),
        D: document.getElementById('optD'),
    };

    let questions = [];
    let currentIndex = -1;
    let currentQuestion = null;
    let score = 0;

    // load list of tables
    async function loadTables(){
        try{
            const res = await fetch('/api/tables');
            const data = await res.json();
            tableSelect.innerHTML = '';
            if(data.tables && data.tables.length){
                data.tables.forEach(t=>{
                    const opt = document.createElement('option');
                    opt.value = t;
                    opt.textContent = t;
                    tableSelect.appendChild(opt);
                });
            } else {
                const opt = document.createElement('option');
                opt.value = '';
                opt.textContent = '-- tests/ klasöründe tablo yok --';
                tableSelect.appendChild(opt);
            }
        }catch(e){
            console.error(e);
        }
    }

    await loadTables();

    // import (load .txt into DB via backend)
    btnImport.addEventListener('click', async ()=>{
        const fname = prompt('tests/ klasöründeki .txt dosya adını yazın (ör. 6_Testing.txt):');
        if(!fname) return;
        const res = await fetch('/api/load_from_txt', {
            method: 'POST',
            headers: {'Content-Type':'application/json'},
            body: JSON.stringify({filename: fname})
        });
        const j = await res.json();
        if(j.ok){
            alert('İçe aktarma tamam. ' + (j.inserted||0) + ' yeni kayıt eklendi.');
            await loadTables();
        }else{
            alert('Hata: ' + (j.error || 'bilinmeyen'));
        }
    });

    // load questions for selected table
    btnLoad.addEventListener('click', async ()=>{
        const table = tableSelect.value;
        if(!table){ alert('Lütfen bir tablo seçin.'); return; }
        const res = await fetch('/api/questions/' + encodeURIComponent(table));
        if(!res.ok){
            const j = await res.json().catch(()=>({}));
            alert('Soru yüklenemedi: ' + (j.error||res.status));
            return;
        }
        const j = await res.json();
        questions = j.questions.slice();
        shuffle(questions);
        score = 0;
        scoreSpan.textContent = '0';
        currentIndex = -1;
        nextBtn.disabled = false;
        loadNext();
        sourceLabel.textContent = 'Kaynak: ' + (j.table || table);
    });

    function shuffle(a){
        for(let i=a.length-1;i>0;i--){
            const r = Math.floor(Math.random()*(i+1));
            [a[i], a[r]] = [a[r], a[i]];
        }
    }

    function setOptionText(key, text){
        const el = optEls[key];
        el.textContent = text;
        adjustFontToFit(el);
    }

    // adjust font-size so text fits comfortably in element (allow multiple lines)
    // adjust font-size so text fits comfortably in element (allow multiple lines)
    function adjustFontToFit(el){
        // daha büyük bir başlangıç değeri kullan
        let base;
        if(window.innerWidth >= 1200){
            base = 34;
        } else if(window.innerWidth >= 900){
            base = 30;
        } else if(window.innerWidth >= 600){
            base = 26;
        } else {
            base = 20;
        }

        // clamp geniş sınırlar
        base = Math.min(48, Math.max(16, base));
        el.style.fontSize = base + 'px';
        el.style.lineHeight = '1.15';

        // eğer taşma varsa yavaşça düşür (daha fazla iterasyon izni)
        const pad = 12;
        for(let i=0;i<50;i++){
            // scrollHeight kontrolü: içerik kutudan taşmıyorsa kır
            if(el.scrollHeight <= el.clientHeight - pad) break;
            let cur = parseInt(window.getComputedStyle(el).fontSize);
            if(cur <= 12) break;
            el.style.fontSize = (cur - 1) + 'px';
        }
    }


    // load next question
    function loadNext(){
        currentIndex++;
        if(currentIndex >= questions.length){
            alert('Tüm sorular tamamlandı! Skorunuz: ' + score);
            nextBtn.disabled = true;
            return;
        }
        const q = questions[currentIndex];
        currentQuestion = q;
        questionEl.textContent = (currentIndex+1) + '. ' + q.question;
        setOptionText('A', q.A || '');
        setOptionText('B', q.B || '');
        setOptionText('C', q.C || '');
        setOptionText('D', q.D || '');

        // reset option styles
        for(const k of Object.keys(optEls)){
            optEls[k].classList.remove('correct','wrong');
            optEls[k].style.pointerEvents = 'auto'; // restore
        }
    }

    // option click handler
    async function onOptionClicked(ev){
        if(!currentQuestion) return;
        const chosenEl = ev.currentTarget;
        const chosenText = chosenEl.textContent;
        // find which option key matches chosenText (could be duplicates - match by content)
        // But easier: data-key attribute gives letter
        const letter = chosenEl.getAttribute('data-key');
        const correctLetter = (currentQuestion.correct || '').toUpperCase();

        // disable further clicks until next
        for(const k of Object.keys(optEls)){
            optEls[k].style.pointerEvents = 'none';
        }

        // color the correct one green
        if(correctLetter && optEls[correctLetter]){
            optEls[correctLetter].classList.add('correct');
        }
        // if wrong, color chosen red
        if(letter !== correctLetter){
            chosenEl.classList.add('wrong');
        }else{
            score++;
            scoreSpan.textContent = score;
        }
    }

    // attach listeners
    for(const k of Object.keys(optEls)){
        optEls[k].addEventListener('click', onOptionClicked);
        // ensure they fit on resize
        window.addEventListener('resize', ()=>adjustFontToFit(optEls[k]));
    }

    nextBtn.addEventListener('click', ()=>{
        loadNext();
    });

    // init tiny helper: adjust question font a bit on resize
    window.addEventListener('resize', ()=> {
        // adjust question size
        const qbase = Math.max(18, Math.round(window.innerWidth/70));
        questionEl.style.fontSize = Math.min(36, Math.max(16, qbase)) + 'px';
        // adjust options
        for(const k of Object.keys(optEls)){
            adjustFontToFit(optEls[k]);
        }
    });

})();
</script>
</body>
</html>
"""
    return Response(html, mimetype="text/html")

if __name__ == "__main__":
    os.makedirs(TESTS_DIR, exist_ok=True)
    # ensure DB exists
    if not os.path.exists(DB_FILE):
        conn = sqlite3.connect(DB_FILE)
        conn.close()
    print("Starting Flask on http://127.0.0.1:5000  — tests klasörü:", TESTS_DIR)
    app.run(debug=True)
